## 面经

1. 为什么投递测试开发岗位？

自己没有项目经历、自己有一份测试实习的经历、结合自己学历背景、当前的技术水平、性格特点、考虑选择测试开发，了解到测试开发也需要进行开发，薪资虽然比开发略低、但是要求没有开发高，也许更容易上岸，并且自己有一个去更大的平台的梦想，所以就把最终的职业目标定在了测试开发。

2. 介绍一下你的实习经历，都做了哪些工作？

公司：生产人工智能芯片，算力卡

自己的职责：对应用到芯片上的驱动程序和软件进行系统测试

我的主要工作：软件测试环境的部署（因为芯片要运行在不同的操作系统上），软件的测试，bug的管理，也会写一些新增功能的case，参与软件产品的迭代

3. 研究方向相关

什么方面级的情感分析：是用特定的深度学习模型来预测一个句子中的方面词对应的情感极性是什么（有积极的，消极的，中性的）？它是一个多分类任务，我们的目标就是通过各种深度学习技术来提高预测的准确率，不说这个研究方向下的比较流行的技术，GAT如注意力机制，还有BERT模型的应用，BERT模型主要用来进行词嵌入，让词向量获得通用的上下文语义信息。除此之外的，还可以结合句子中的存在的句法知识和不同成分之间形成的树形结构，通过嵌入这些关系来提高最终模型的预测精度。

什么是中医智能处方：其实他也是一个多分类模型，只不过是相同的深度学习技术的不同应用而已，我们通过输入病人的症状集合，来预测对应的中药集合，在建立模型时，我们可以考虑用图注意力机制来嵌入病人的个体特征或者不同症状或者症状中药等之间的关系，通过让模型学习各种关系，来提高最终模型的准确率。在模型进行处理的每个阶段，可以融入中医的理论体系，比如说中医给人看病时，要经过辩证和论治两个阶段，然后再更具治法进行谴药组方，也就是说我们可以利用深度学习技术对中医处方的流程来进行建模，模拟中医看病的过程，通过大规模的数据集的训练，以达到中医智能辅助诊疗的目的。

4. python 的装饰器

在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。

```
import functools

def log(func):
    @functools.wraps(func)  # 把还原原始函数的__name__属性（没有这行__name__会变成wraps）
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
```

```
import functools

def log(text):
    def decorator(func):
        @functools.wraps(func) # 把还原原始函数的__name__属性（没有这行__name__会变成wraps）
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
```

4. python 高级特性有哪些

切片：取指定索引范围的操作 L[0:3] 后10个数：L[-10:] 前10个数，每两个取一个:L[:10:2]

**tuple也是一种list，唯一区别是tuple不可变**

迭代:可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。

**默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values(), 如果要同时迭代key和value，可以用for k, v in d.items()。**

判断是否可迭代：

    ```
    from collections.abc import Iterable 
    isinstance('abc', Iterable) # str是否可迭代
    ```

列表生成式:是Python内置的非常简单却强大的可以用来创建list的生成式。

**在一个列表生成式中，for前面的if ... else是表达式，而for后面的if是过滤条件，不能带else**

生成器:在Python中，这种一边循环一边计算的机制，称为生成器：generator。

generator保存的是算法，generator也是可迭代对象：

5. python 多线程开发

多进程：

    先创建子进程

    用start()方法启动

    join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。

Pool：如果要启动大量的子进程，可以用进程池的方式批量创建子进程

    p = Pool(4)

    批量创建进程

    p.close() # 调用close()之后就不能继续添加新的Process了。

    p.join() # 对Pool对象调用join()方法会等待所有子进程执行完毕，

进程间通信：有几种方式，有可能陷入死锁

多线程：

启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行（任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程）

1. 创建线程
2. 线程.start()
3. 线程.join()

继续执行主线程

线程锁：多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此需要锁











