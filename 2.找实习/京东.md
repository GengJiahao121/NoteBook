12月12日腾讯视频面试：（面试非常舒服，一直在问我实习的时候干了什么，并对我做的东西给以肯定，我们两个技术的交流非常输出，我想他也是纯搞技术的吧，并且想多了解了解各个领域的知识）

1. python

    1. [装饰器/闭包讲解链接](https://www.cnblogs.com/linxiyue/p/11224322.html)

        装饰器

            在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。

            ```
            import functools

            def log(func):
                @functools.wraps(func)  # 把还原原始函数的__name__属性（没有这行__name__会变成wraps）
                def wrapper(*args, **kw):
                    print('call %s():' % func.__name__)
                    return func(*args, **kw)
                return wrapper
            ```

            ```
            import functools

            def log(text):
                def decorator(func):
                    @functools.wraps(func) # 把还原原始函数的__name__属性（没有这行__name__会变成wraps）
                    def wrapper(*args, **kw):
                        print('%s %s():' % (text, func.__name__))
                        return func(*args, **kw)
                    return wrapper
                return decorator
            ```

        闭包

        嵌套函数就是闭包。闭包是指延伸了作用域的函数，在其中能够访问未在函数定义体中定义的非全局变量。未在函数定义体中定义的非全局变量一般都是在嵌套函数中出现的。

        Python函数中的全局变量或者自由变量是不可变对象(数字、字符串、元组等)时，是只能读取，无法更新。如果将更新这个不可变对象，方法就是使用global或者nonlocal在函数体内将变量声明为全局变量或者自由变量

        装饰器与闭包的关系：使用装饰器会用到闭包这样的一个概念。

    2. return / yield

    不同点：如果要返回的数据是通过for等循环生成的迭代器类型数据（如列表、元组），**return只能在循环外部一次性地返回**，yeild则可以在循环内部逐个元素返回。下边我们举例说明这个不同点。

    ```
    class TestYield:
    def gen_iterator(self):
        for j in range(3):
            print(f"do_something-{j}")
            # yield在for循环内部
            yield j

    def call_gen_iterator(self):
        # yield并不是直接返回[0,1,2]，执行下边这句后result_list什么值都没有
        result_list = self.gen_iterator()
        # i每请求一个数据，才会触发gen_iterator生成一个数据
        for i in result_list:
            print(f"call_gen_iterator-{i}")

    if __name__ == "__main__":
        obj = TestYield()
        obj.call_gen_iterator()
    ```

    执行结果如下，可以看到上下层函数是交替进行的，即上层函数请求迭代一个值下层函数才生成一个值并立即返回这个值：

    ```
    do_something-0
    call_gen_iterator-0
    do... 1
    call ... 1
    do ... 2
    call ... 2
    ```

    而return是一次性返回

    当result_list的长度很长且每个组成元素内容很大时将会耗费比较大的内存，此时yield相对return才有优势。

2. 接口测试 你会关注到那些点

web接口测试一般关注的点：
    1. 接口的入参数、出参数、入参是否可省略，入参的顺序（正常输入，成功/异常输出，错误）
    2. 接口地址
    3. 鉴权、错误码（指定某种情况是否会正常出现）
       1. 正例：
       2. 反例： 鉴权反例：为空，鉴权码错误、鉴权码已过期
   
                参数反例：参数为空、类型异常、长度异常、

                错误码的覆盖。

                其他的场景：分页异常
chatgpt:
   1. 请求和响应验证：符合API文档的规范。验证参数、数据格式、数据类型等是否正确。
   2. 状态码检查
   3. 数据一致性：返回的数据与预期结果是否一致
   4. 性能测试
   5. 安全性：检查接口是否受到足够的安全保护，包括身份验证、授权、加密传输等。
   6. 边界值测试：测试接口的极端情况，包括最小值、最大值、空值等，以确保接口在各种情况下都能正常工作。
   7. 错误处理：测试接口对于无效请求的处理，包括错误消息的清晰度、格式等。确保系统能够正确处理异常情况。
   8. 并发测试： 检查接口在并发请求的情况下是否能够正确处理和响应。
   9. 日志和监控： 确保接口的日志记录和监控机制正常工作，以便及时发现和解决问题。
   10. 版本控制： 如果存在多个接口版本，确保在升级过程中不会破坏现有的集成。
   11. 文档一致性： 确保接口文档与实际实现一致，及时更新文档以反映任何更改。
   12. 兼容性测试： 如果接口在不同平台或设备上使用，确保接口在各种环境下都能正常工作。
   13. 缓存和性能优化： 如果接口使用了缓存机制，确保缓存的一致性，并测试性能优化措施的有效性。


3. 做过性能测试吗

    1. 对于webserver的性能测试：
       1. 通过webbench来fork出指定数量的子进程模拟用户访问服务器，并将访问结果返回给主进程进行统计，进而时间对webserver服务器的性能和压力测试。
    2. 
4. 你的研究方向如何应用在测试上，有哪些应用呢？（考察你的发散思维）

12月13日正式一面：
1. 测试流程
2. 你是怎么判断有问题的
3. 你有没有设计过case(我说过了好几次，还问我，后来我说我们公司测试流程可能没有那么的正规，没有先与开发那面沟通，确定测试需求....正因为这样，所以想去更大一点的公司去学习，她好像听懂了！... )我应该怎么总结呢？？？
4. 有没有喜欢的大厂
5. 投递了其他的公司了吗
6. 你为什么选择测试开发
7. 反问：一共几面、两轮业务面，一轮hr面


12.14日晚8点：

等不及了去官网查了一下，发现变成带筛选了

明明给我的感觉很好，但是为什么就挂了呢？不明白，很伤。

到底要经历多少次这种给你希望，又很快让你失望，才能开心啊，为什么这么难啊

我应该怎么做啊！我现在也想当一个海王，不会这么傻傻的等着公司却等来了拒绝了。