# 代码随想录算法训练营第24天｜回溯算法part01｜理论基础、77. 组合

## 理论基础

[理论基础](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB%E5%A4%A7%E7%BA%B2%E5%A6%82%E4%B8%8B)

回溯函数也就是递归函数，指的都是一个函数

回溯也可以理解为**for循环里面嵌套着递归**

### 回溯法的效率

虽然回溯法很难，很不好理解，但是回溯法**并不是什么高效的算法**。

因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案，如果想让回溯法高效一些，**可以加一些剪枝的操作**，但也改不了回溯法就是穷举的本质。

**组合是不强调元素顺序的，排列是强调元素顺序**

### 回溯法解决的问题

组合问题：N个数里面按一定规则找出k个数的集合

切割问题：一个字符串按一定规则有几种切割方式

子集问题：一个N个数的集合里有多少符合条件的子集

排列问题：N个数按一定规则全排列，有几种排列方式

棋盘问题：N皇后，解数独等等

### 如何理解回溯法

回溯法解决的问题都可以**抽象为树形结构**

因为回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，递归的深度，都构成的树的深度。**

递归就要有终止条件，所以必然是一棵**高度有限的树（N叉树）。**

### 回溯法模板

回溯三部曲

- 回溯函数模板返回值以及参数

	回溯算法中函数返回值一般为void；
	
	再来看一下参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以**一般是先写逻辑，然后需要什么参数，就填什么参数**。

	```
	void backtracking(参数)
	```

- 回溯函数终止条件

	什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。
	```
	if (终止条件) {
        存放结果;
        return;
    }
	```

- 回溯搜索的遍历过程

	在上面我们提到了，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。

	![在这里插入图片描述](https://img-blog.csdnimg.cn/e0f23f07f3a943ff950d0a04444dc559.png)
	注意图中，我特意举例**集合大小**和**孩子的数量**是**相等**的！

	回溯函数遍历过程伪代码如下：

	```
	for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
   			处理节点;
    		backtracking(路径，选择列表); // 递归
    		回溯，撤销处理结果
	}
	```
	**for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。**

	backtracking这里自己调用自己，实现递归。

	大家可以从图中看出for循环可以理解是**横向遍历**，backtracking（递归）就是**纵向遍历**，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。
	
	分析完过程，回溯算法模板框架如下：
	
	```
	void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
	}
	```

## 77. 组合

[77. 组合](https://leetcode.cn/problems/combinations/)

**代码随想录**

思路：

![在这里插入图片描述](https://img-blog.csdnimg.cn/7963afbee90e489e930c11652d0983b6.png)

**每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围。**

**图中可以发现n相当于树的宽度，k相当于树的深度。**

那么如何在这个树上遍历，然后收集到我们要的结果集呢？

图中每次搜索到了叶子节点，我们就找到了一个结果。

**相当于只需要把达到叶子节点的结果收集起来，就可以求得 n个数中k个数的组合集合。**


**剪支**

来举一个例子，n = 4，k = 4的话，那么第一层for循环的时候，从元素2开始的遍历都没有意义了。

![在这里插入图片描述](https://img-blog.csdnimg.cn/24140b77c80a40da87e45380096ed8c0.png)

图中每一个节点（图中为矩形），就代表本层的一个for循环，那么每一层的for循环从第二个数开始遍历的话，都没有意义，都是无效遍历。

所以，可以剪枝的地方就在递归中每一层的for循环所选择的起始位置。

如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了。

优化过程如下：

1. 已经选择的元素个数：path.size();
2. 还需要的元素个数为: k - path.size();
3. 在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历
为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。

举个例子，n = 4，k = 3， 目前已经选取的元素为0（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 = 2。

从2开始搜索都是合理的，可以是组合[2, 3, 4]。

这里大家想不懂的话，建议也举一个例子，就知道是不是要+1了。

`for (int i = startIndex; i <= n - (k - path.size()) + 1; i++) // i为本次搜索的起始位置`

代码：

python

```
class Solution(object):
    def __init__(self):
        self.path = []
        self.result = []
    def combine(self, n, k):
        """
        :type n: int
        :type k: int
        :rtype: List[List[int]]
        """
        self.backtracking(n, k, 1)
        return self.result

    def backtracking(self, n, k, startIndex): # 1. 确定参数和返回值
        # 2. 确定终止条件
        if len(self.path) == k:
            #print(self.path)
            self.result.append(list(self.path))
            return 
        # 3. 确定单层递归逻辑
        for index in range(startIndex, n+1):
            self.path.append(index)
            self.backtracking(n, k, index+1)
            self.path.pop()

        return 
'''
注意：
在将 path 添加到 result 列表时可能遇到问题，导致返回的 result 结果为空列表。
由于 path 是一个可变对象，当你在后续的递归调用中修改 path 时，之前添加到 result 中的组合结果也会被修改。因此，最终的 result 结果将只包含相同的列表对象 path 的多个引用，这会导致结果为空列表。
'''
```

## 




	
	

	


