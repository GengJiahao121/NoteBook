#### 1、CPP怎么实现多态？

cpp的多态分为静态多态和动态动态

静态多态依靠**重载**函数实现。

同名但是参数返回值不相同的函数在编译器层次的命名修饰不一样，可是实现一函数名多用

动态多态依靠**虚函数**和**模板函数**实现。

虚函数在基类定义，派生类的同名函数必须返回值参数一致，完成重写。每个类会有一张虚函数表记录这个类需调用的函数。每个类的实例对象都有一个虚函数指针指向这个表。
这样基类指向派生类调用同名函数就会根据派生类的虚函数表，调用派生类的函数。

模板则是**编译时不生成实例**，当使用特定类型使用函数模板时，根据实参类型，生成对应类型的函数实例。实现模板多用的多态

#### 2、静态局部变量，全局变量，局部变量的特点，以及使用场景

静态局部变量：

当程序执行到它的声明处首次被初始化，以后就不会被初始化了，直到程序结束。该变量被存储在全局静态区，它的作用域是局部的，当定义它的函数或语句结束时，它的作用域就结束了。

全局变量：

该变量作用域为整个文件，非常适合存储全局性的数据。

局部变量：

该变量的作用域是局部的，当定义它的函数或语句结束时，它的作用域就结束了。它适合用于临时存储计算结果或中间数据。在存储过程或函数中，我们可以使用局部变量来存储临时计算结果，这样不仅可以提高查询性能，还能让代码更加清晰易懂。

生命周期：

局部变量在栈上，出了作用域就回收内存，静态局部变量和全局变量是在静态存储区，当程序结束时回收内存。

#### 3、都说c++是面向对象的语言，面向对象的三个特性能 [展开] 介绍一下吗？

c++面向对象的三大特性是：继承，封装和多态。

1.继承就是让某种类型对象继承另一种类型对象的属性和方法。它可以使用现有类的所有功能，并在原来类的基础上对这些功能进行扩展。

继承又分为实现继承，接口继承和可视继承。

实现继承是指使用基类的属性和方法而无需额外编码的能力。

接口继承是指仅使用基类的属性和方法名称，但必须提供实现代码的能力。

可视继承是指子类使用基类的外观和实现代码的能力。

2.封装是指将数据和代码捆绑在一起，防止外界干扰或不确定性访问。通过将客观事物封装成抽象的类，并且可以类把自己数据和方法只让可信的类或对象操作，对不可信的信息进行隐藏。

3.多态指的是同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同对象在接受到时会产生不同行为。

（重载实现编译时多态，虚函数实现运行时多态）多态允许将子类类型的指针赋值给父类类型的指针。

实现多态的两种方式分别是覆盖和重载。覆盖是指子类重新定义父类虚函数的做法，重载是允许存在多个同名函数，而这些函数的参数列表不同。

#### 4、new 和 malloc的区别

1. new 和 delete 是C++的操作符，而 malloc 和 free 是C语言的库函数
2. new 会调用构造函数（同理 delete 会调用析构函数），而 malloc 和 free 不会
3. new返回的是对象的指针，而malloc返回的是 void 类型（泛型指针）
4. new操作符申请内存分配时不需要指定内存大小，而 malloc 需要显示的指出所需内存的大小
5. new分配内存失败时，会抛出 bad_alloc 异常，而 malloc 会返回 NULL
7. new申请内存时从自由存储区为对象分配，而 malloc 从堆区分配
8. new是一个操作符，可以进行重载，而 malloc 不行
9. new 是类型安全的，malloc 不是（malloc 返回的是一个 void* 类型，需要进行强制类型转换）

#### 5、static关键字和const关键字的作用

const

    声明变量为常量，使得变量不能被修改，避免误操作。

    加在指针前面，const int* p可以使得指针指向的元素不变

    int* const p可以使得指针指向的位置不变

    加在函数后面void func() const可以使得函数不会修改任何变量。

static

声明静态变量，静态变量的生命周期直到程序结束。

当在函数内部声明静态变量时，即使函数执行完了也不会释放它，下次调用该函数时会保留上次的状态。

在类中，被static声明的成员被称为静态成员。所有静态成员变量共享一个内存空间，即无论实例化多少个对象，其中的静态成员都是共享的。**静态成员函数只能访问静态成员变量**

静态成员变量只能在类外进行初始化

#### 6、什么是智能指针，C++ 中有哪几种智能指针？

首先，提到智能指针就必须知道RAII（Resource Acquisition Is Initialization，资源获取即初始化）的编程思想。

RAII是C++语言的一种管理资源、避免泄漏的惯用法。简单说来，RAII 的做法就是使用一个对象，在其构造时获取资源，在对象生命期控制对资源的访问使之始终保持有效，最后在对象析构的时候释放资源。

智能指针则深刻的体现了这种思想。在现代 C++ 编程中，标准库包含智能指针，该指针用于确保程序不存在内存和资源泄漏且是线程安全的。

智能指针本质就是一个类模板，它可以创建任意的类型的指针对象，当智能指针对象使用完后，对象就会自动调用析构函数去释放该指针所指向的空间。

C++有auto_ptr（已被摒弃）、unique_ptr、share_ptr以及weak_ptr。

unique_ptr：具有移动语义，不允许复制或者赋值（源码中将拷贝构造函数和赋值运算符函数=delete，禁用了）。可以作为容器的元素（容器中可以存unique_ptr类型元素）

share_ptr：一个共享所有权的智能指针，允许对象之间进行复制或者赋值，展示出来的就是值语义。使用引用计数的观点。当对象之间进行复制或者赋值的时候，引用计数会加+1，当最后一个对象销毁的时候，引用计数减为0，此时会回收托管的空间。

weak_ptr：常用于解决share_ptr循环引用的问题，weak_ptr类的对象可以指向shared_ptr，并且不会改变shared_ptr的引用计数。一旦最后一个shared_ptr被销毁时，对象就会被释放。

#### 7、C++ 中的虚函数和纯虚函数有什么区别？

虚函数是为了实现**动态编联**产生的，目的是通过基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数（使用同一种调用形式，既能调用派生类又能调用基类的同名函数）。虚函数需要在基类中加上virtual修饰符修饰，因为virtual会被**隐式继承**，所以子类中相同函数都是虚函数。当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数，在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同。

纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化。

纯虚函数首先是虚函数，其次它没有函数体，取而代之的是用“=0”。

既然是虚函数，它的函数指针会被存在虚函数表中，由于纯虚函数并没有具体的函数体，因此它在虚函数表中的值就为0，而具有函数体的虚函数则是函数的具体地址。

一个类中如果有纯虚函数的话，称其为抽象类。抽象类不能用于实例化对象，否则会报错。抽象类一般用于定义一些公有的方法。子类继承抽象类也必须实现其中的纯虚函数才能实例化对象。

举个例子：

```
#include <iostream>
using namespace std;

class Base
{
public:
	virtual void fun1()
	{
		cout << "普通虚函数" << endl;
	}
	virtual void fun2() = 0;
	virtual ~Base() {}
};

class Son : public Base
{
public:
	virtual void fun2() 
	{
		cout << "子类实现的纯虚函数" << endl;
	}
};

int main()
{
	Base* b = new Son;
	b->fun1(); //普通虚函数
	b->fun2(); //子类实现的纯虚函数
	return 0;
}
```

#### 8、C++11 中的新特性有哪些？

#### 9、c++的map和unordered_map有什么区别

#### 10、什么是内存泄漏？什么是野指针？什么是内存越界？如何避免？

#### 11、new/delete区别

#### 12、说一下select、poll、epoll

Select、Poll 和 Epoll

Select
select 实现多路复用的方式是，将已连接的 Socket 都放到一个文件描述符集合，然后调用 select 函数将文件描述符集合拷贝到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过遍历文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合拷贝回用户态里，然后用户态还需要再通过遍历的方法找到可读或可写的 Socket，然后再对其处理。
对于 select 这种方式，需要进行 2 次「遍历」文件描述符集合，一次是在内核态里，一个次是在用户态里 ，而且还会发生 2 次「拷贝」文件描述符集合，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。
select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 1024，只能监听 0~1023 的文件描述符。

执行原理：
1、将当前进程的所有文件描述符，一次性的从用户态拷贝到内核态。
2、在内核中快速的无差别的遍历每个 fd ，判断是否有数据到达。
3、将所有 fd 状态，从内核态拷贝到用户态，并返回已就绪 fd 的个数。
4、在用户态遍历判断具体哪个 fd 已就绪，然后进行相应的事件处理。

限制和不足：
1、文件描述符是 bitmap 结构，且有长度为 1024 的限制。
2、fdset 无法做到重用，每次循环都必须重新创建。
3、频繁的用户态和内核态拷贝，性能开销较大。
4、需要对文件描述符表进行遍历，O(n) 的轮询时间复杂度。

Poll
poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。
但是 poll 和 select 并没有太大的本质区别，都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合，这种方式随着并发数上来，性能的损耗会呈指数级增长。

```C++
// pollfd 结构体原型
struct pollfd{
  int fd;//文件描述符
  short events;//注册的事件
  short revents;//实际发生的事件，由内核填充
}
```

限制和不足：
1、poll 模型采用的是 pollfd 结构数组，解决了 Select 的 1024 个文件描述符的限制。
2、仍然存在频繁的用户态和内核态拷贝，性能开销较大。
3、需要对文件描述符表进行遍历，O(n) 的轮询时间复杂度。

Epoll
如下的代码中，先用epollcreate 创建一个 epoll 对象 epfd，再通过 epollctl 将需要监视的 socket 添加到 epfd 中，最后调用 epoll_wait 等待数据。

```C++
int s = socket(AF_INET, SOCK_STREAM, 0);
bind(s, ...);
listen(s, ...)

int epfd = epoll_create(...);
epoll_ctl(epfd, ...); //将所有需要监听的socket添加到epfd中

while(1) {
    int n = epoll_wait(...);
    for(接收到数据的socket){
        //处理
    }
}
```

epoll 通过两个方面，很好解决了 select/poll 的问题。
1、epoll 在内核里使用红黑树来跟踪进程所有待检测的文件描述字，把需要监控的 socket 通过 epoll_ctl() 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是 O(logn)。而 select/poll 内核里没有类似 epoll 红黑树这种保存所有待检测的 socket 的数据结构，所以 select/poll 每次操作时都传入整个 socket 集合给内核，而 epoll 因为在内核维护了红黑树，可以保存所有待检测的 socket ，所以只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。
2、epoll 使用事件驱动的机制，内核里维护了一个链表来记录就绪事件，当某个 socket 有事件发生时，通过回调函数内核会将其加入到这个就绪事件列表中，当用户调用 epoll_wait() 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。

epoll 相关的接口作用：
epoll 的方式即使监听的 Socket 数量越多的时候，效率不会大幅度降低，能够同时监听的 Socket 的数目也非常的多了，上限就为系统定义的进程打开的最大文件描述符个数。因而，epoll 被称为解决 C10K 问题的利器。
epoll_wait 实现的内核代码中调用了 __put_user 函数，这个函数就是将数据从内核拷贝到用户空间。

```C++
// epoll_event 结构体原型
struct pollfd{
  __uint32_t events;
  epoll_data_t data;
}

typedef union epoll_data{
  void* ptr;
  int fd;
  __uint32_t u32;
  __uint64_t u64;
}epoll_data_t;
```

Epoll 的优势：
1、在 epoll_ctl() 函数中，为每个文件描述符都指定了回调函数，基于回调函数把就绪事件放到就绪队列中，因此，把时间按复杂度从 O(n) 降到了 O(1)。
2、只需要在 epollctl() 时传递一次文件描述符， epollwait() 不需要再次传递文件描述符。
3、epoll 基于红黑树 + 双链表存储事件，没有最大连接数的限制，不存在 C10K 问题。
4、Epoll 并没有使用 MMAP 零拷贝技术。

#### 13 什么是协程



####

####

####

####

####

####
