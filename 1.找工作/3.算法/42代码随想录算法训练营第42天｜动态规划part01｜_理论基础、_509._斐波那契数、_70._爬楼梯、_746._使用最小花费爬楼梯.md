# 代码随想录算法训练营第42天｜动态规划part01｜ 理论基础、 509. 斐波那契数、 70. 爬楼梯、 746. 使用最小花费爬楼梯

##  理论基础

[理论基础](https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)

## 斐波那契数

[斐波那契数](https://leetcode.cn/problems/fibonacci-number/description/)

**代码随想录**

思路：

**但「代码随想录」的风格是：简单题目是用来加深对解题方法论的理解的。**

通过这道题目让大家可以初步认识到，按照动规五部曲是如何解题的。

动态规划

动规五部曲：

这里我们要用一个一维dp数组来保存递归的结果

1. 确定dp数组以及下标的含义

dp[i]的定义为：第i个数的斐波那契数值是dp[i]

2. 确定递推公式

为什么这是一道非常简单的入门题目呢？

**因为题目已经把递推公式直接给我们了：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];**

3. dp数组如何初始化

题目中把如何初始化也直接给我们了，如下：

`dp[0] = 0;
dp[1] = 1;`

4. 确定遍历顺序

从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的

5. 举例推导dp数组

按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：

0 1 1 2 3 5 8 13 21 34 55

如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。

代码：

python

```
class Solution(object):
    def fib(self, n):
        """
        :type n: int
        :rtype: int
        """
        if n <= 1:
            return n
        
        # 1. 确定dp数组以及下标的含义
        dp = [0] * (n+1)

        # 2. 确定递推公式
        '''dp[i] = dp[i-1] + dp[i-2]'''
        # 3. dp数组如何初始化
        dp[0] = 0
        dp[1] = 1

        # 4. 确定遍历顺序
        for i in range(2, n+1):
            dp[i] = dp[i-1] + dp[i-2]

        # 5. 举例推导

        return dp[n]
```

## 70. 爬楼梯

[70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

**代码随想录**

思路：

爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。

那么第一层楼梯再跨两步就到第三层 ，第二层楼梯再跨一步就到第三层。

所以到**第三层楼梯的状态可以由第二层楼梯 和 到第一层楼梯状态推导出来**，那么就可以想到动态规划了。

我们来分析一下，动规五部曲：

定义一个一维数组来记录不同楼层的状态

1. 确定dp数组以及下标的含义

dp[i]： 爬到第i层楼梯，有dp[i]种方法

2. 确定递推公式

如何可以推出dp[i]呢？

从dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。

首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。

还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。

那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！

所以dp[i] = dp[i - 1] + dp[i - 2] 。

**在推导dp[i]的时候，一定要时刻想着dp[i]的定义，否则容易跑偏。**

这体现出确定dp数组以及**下标的含义的重要性！**

3. dp数组如何初始化

再回顾一下dp[i]的定义：爬到第i层楼梯，有dp[i]种方法。

那么i为0，dp[i]应该是多少呢，这个可以有很多解释，但基本都是直接奔着答案去解释的。

例如强行安慰自己爬到第0层，也有一种方法，什么都不做也就是一种方法即：dp[0] = 1，相当于直接站在楼顶。

但总有点牵强的成分。

那还这么理解呢：我就认为跑到第0层，方法就是0啊，一步只能走一个台阶或者两个台阶，然而楼层是0，直接站楼顶上了，就是不用方法，dp[0]就应该是0.

其实这么争论下去没有意义，大部分解释说dp[0]应该为1的理由其实是因为dp[0]=1的话在递推的过程中i从2开始遍历本题就能过，然后就往结果上靠去解释dp[0] = 1。

从dp数组定义的角度上来说，dp[0] = 0 也能说得通。

需要注意的是：题目中说了n是一个正整数，题目根本就没说n有为0的情况。

**所以本题其实就不应该讨论dp[0]的初始化！**

**我相信dp[1] = 1，dp[2] = 2，这个初始化大家应该都没有争议的。**

**所以我的原则是：不考虑dp[0]如何初始化，只初始化dp[1] = 1，dp[2] = 2，然后从i = 3开始递推，这样才符合dp[i]的定义。**

4. 确定遍历顺序

从递推公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的

6. 举例推导dp数组

举例当n为5的时候，dp table（dp数组）应该是这样的

![在这里插入图片描述](https://img-blog.csdnimg.cn/a569ff1240b94f18b50b8b3ba36a79fc.png)

**此时大家应该发现了，这不就是斐波那契数列么！**

代码：

python

```
class Solution(object):
    def climbStairs(self, n):
        """
        :type n: int
        :rtype: int
        """
        if n == 1:
            return 1
        if n == 2:
            return 2 

        # 1. 
        dp = [0] * (n+1)

        # 3. 
        dp[1] = 1
        dp[2] = 2

        # 4.
        for i in range(3, n+1):
            # 2.
            dp[i] = dp[i-1] + dp[i-2]

        return dp[n]
```

##  746. 使用最小花费爬楼梯 

[ 746. 使用最小花费爬楼梯 ](https://leetcode.cn/problems/min-cost-climbing-stairs/)

**自己做**

思路：

这道题做完了前两道题目就有思路了

代码：

python

```
class Solution(object):
    def minCostClimbingStairs(self, cost):
        """
        :type cost: List[int]
        :rtype: int
        """
        # 1. 每个值表示到达当前楼梯的最低消费
        dp = [0] * (len(cost)+1)

        # 2. 递推公式

        # 3. 数组的初始值
        dp[0] = 0
        dp[1] = 0

        # 4. 确定循环的顺序，从前往后
        for i in range(2, len(cost)+1):
            dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])
        
        return dp[-1]


```

**代码随想录**同自己想的一样，只不过我做的时候长度少一1，如图，**n+1位置才是楼顶**

![在这里插入图片描述](https://img-blog.csdnimg.cn/cf30405d1585476abab4b484962929af.png)






